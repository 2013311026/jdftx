<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>JDFTx: Lattice optimization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="jdftx-55.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">JDFTx
   &#160;<span id="projectnumber">1.2.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('LatticeOpt.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lattice optimization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="LatticeOpt.gif" alt="LatticeOpt.gif"/>
</div>
<p>The previous tutorials have calculated properties of silicon at fixed geometry, which in the case of a crystal includes the ionic positions as well as the lattice vectors. To optimize the ionic positions at fixed lattice vectors, command <a class="el" href="CommandIonicMinimize.html">ionic-minimize</a> suffices as in the molecular cases (see the <a class="el" href="GeometryOpt.html">Geometry optimization</a> tutorial for example). This tutorial introduces lattice optimization using the <a class="el" href="CommandLatticeMinimize.html">lattice-minimize</a> command.</p>
<p>We'll start with the essentially the same input as the previous tutorials, but in order to test the minimizer, we'll artificially introduce a strain: </p>
<pre class="fragment">#Save the following to Si.lattice
lattice face-centered Cubic 11.3   #this is deliberately about 10% too large
</pre><p>and specify the ionic positions to a separate file as well: </p>
<pre class="fragment">#Save the following to Si.ionpos
ion Si 0.00 0.00 0.00  1
ion Si 0.30 0.30 0.30  1   #deliberately perturbed (should have been 0.25)
</pre><p>and the input file for lattice optimization: </p>
<pre class="fragment">#Save the following to latticeOpt.in
include Si.lattice
include Si.ionpos

kpoint-folding 8 8 8
ion-species GBRV/$ID_pbe_v1.2.uspp
ion-species GBRV/$ID_pbe_v1.01.uspp
ion-species GBRV/$ID_pbe_v1.uspp
elec-cutoff 20 100

electronic-SCF                   #Electronic state optimization
ionic-minimize nIterations 10    #Internal geometry optimization
lattice-minimize nIterations 10  #Lattice geometry optimization
dump-name Si.$VAR
dump Lattice State               #Output state every lattice step
</pre><p>For silicon, symmetries completely determine the internal geometry (fractional ion coordinates), and therefore only lattice optimization is necessary. But in order to illustrate a more general situation, the above input starts from a perturbed internal geometry as well. Therefore, we specify commands for both ionic and lattice minimization.</p>
<p>Run JDFTx on this input file a few times: </p>
<pre class="fragment">mpirun -n 4 jdftx -i latticeOpt.in | tee latticeOpt.out
mpirun -n 4 jdftx -i latticeOpt.in | tee -a latticeOpt.out
</pre><p>Note that each run updates both Si.lattice and Si.ionpos, so that the next one starts at the final geometry of the previous one. However, we deliberately do not read in the wavefunctions of the previous run (using <a class="el" href="CommandInitialState.html">initial-state</a>) in the subsequent runs. Once the lattice changes, the plane-wave basis within the specified kinetic energy cutoff will change making the wavefunctions incompatible.</p>
<p>Within each run, the basis is kept constant because otherwise the energy would change discontinuously with varying lattice vectors, making it impossible to use an efficient minimization algorithm. However, this means that the basis is inconsistent with the original <a class="el" href="CommandElecCutoff.html">elec-cutoff</a> once the lattice vectors have changed from the input value. This is why it is essential to rerun lattice optimizations a few times, especially if the initial strain is large, and stop when the lattice changes negligibly (around 0.1%) in a given run. (This issue can be mitigated partially using <a class="el" href="classPulay.html" title="Pulay mixing to optimize self-consistent field optimization  ">Pulay</a> corrections - see script <a class="el" href="calcPulay.html">calcPulay</a> - but it is important to continue the lattice minimization over a few runs regardless.)</p>
<p>Examine the output file. Note the usual ionic minimize output, which performs electronic-SCF repeatedly at several geometries till the forces are within threshold. But now additionally, there is a lattice minimizer which runs an ionic minimization at each lattice geometry. At the end of the ionic minimization at one lattice geometry, it calculates and reports the stress and strain tensors, following which it updates the lattice vectors and iterates. Note that in the present case, the first run ends with a strain of -8.5%, while the second run ends with a strain less than 0.001%, so we can stop after the second run; but often more runs will be necessary.</p>
<p>You can easily see this inner-outer minimization structure using "grep Minimize latticeOpt.out". In this case it only prints IonicMinimize and LatticeMinimize since we used electronic-SCF; if we didn't specify electronic-SCF, you would also see ElecMinimize in that output. You can also visualize the convergence of the energy using the <a class="el" href="plotConvergence.html">plotConvergence</a> script. By default "plotConvergence latticeOpt.out" will plot the convergence every electronic iteration, but you can use "iterType=Ionic plotConvergence latticeOpt.out" or "iterType=Lattice plotConvergence latticeOpt.out" to examine the convergence with ionic or lattice opimization steps.</p>
<p>Check the final lattice vectors and internal geometry (Si.lattice and Si.ionpos). The final lattice is face-centered Cubic with a cubic lattice constant of 10.33 bohrs, which is only 0.7% larger than the experimental value of 10.263 bohrs (typical accuracy for the PBE exchange-correlation functional). Note that the ionic positions have a net translation to the ones we specified in previous tutorials: the optimizer moved both Si atoms in the unit cell toward each other to fix the perturbation we introduced. Of course, with periodic boundary conditions and the plane-wave basis, this makes no difference at all. If we wanted to keep the first Si atom pinned to the origin, we could have zero'd its moveScale factor (last parameter to ion command).</p>
<p>Finally, we can export the variation of the geometry using </p>
<pre class="fragment">createXSF latticeOpt.out latticeOpt.axsf Animated
</pre><p>and examine the animated XSF file using XCrysDen (since VESTA doesn't support animated XSFs). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
