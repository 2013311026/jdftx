<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>JDFTx: core/BlasExtra.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="jdftx-55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JDFTx
   &#160;<span id="projectnumber">1.1.2</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('BlasExtra_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BlasExtra.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Commonly used BLAS-like routines.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;gsl/gsl_cblas.h&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;cstdio&gt;</code><br />
<code>#include &lt;cfloat&gt;</code><br />
<code>#include &lt;core/scalar.h&gt;</code><br />
<code>#include &lt;<a class="el" href="Thread_8h_source.html">core/Thread.h</a>&gt;</code><br />
<code>#include &lt;cublas.h&gt;</code><br />
<code>#include &lt;cuda_runtime.h&gt;</code><br />
</div>
<p><a href="BlasExtra_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1d6b0e34680298982988b556e5ae0312"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d6b0e34680298982988b556e5ae0312"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a1d6b0e34680298982988b556e5ae0312">eblas_dscal_gpu</a>&#160;&#160;&#160;cublasDscal</td></tr>
<tr class="memdesc:a1d6b0e34680298982988b556e5ae0312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#aaf6bba434761869bd04fbd191859cc67" title="Scale a real array: threaded wrapper to the cblas_dscal BLAS1 function. ">eblas_dscal()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a1d6b0e34680298982988b556e5ae0312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a5c5c58dd853cf7a55f972bfdc9312"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23a5c5c58dd853cf7a55f972bfdc9312"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a23a5c5c58dd853cf7a55f972bfdc9312">eblas_daxpy_gpu</a>&#160;&#160;&#160;cublasDaxpy</td></tr>
<tr class="memdesc:a23a5c5c58dd853cf7a55f972bfdc9312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#aad007d0c4eb9fe5c141f9d48bb0dd710" title="Scaled-accumulate on real arrays: threaded wrapper to the cblas_daxpy BLAS1 function. ">eblas_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a23a5c5c58dd853cf7a55f972bfdc9312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed560fa37afc8e9efabedada3f0601a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ed560fa37afc8e9efabedada3f0601a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a6ed560fa37afc8e9efabedada3f0601a">eblas_ddot_gpu</a>&#160;&#160;&#160;cublasDdot</td></tr>
<tr class="memdesc:a6ed560fa37afc8e9efabedada3f0601a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#affe4a0ee242ac993d41a38f9914dc583" title="Dot product of real arrays: threaded wrapper to the cblas_ddot BLAS1 function. ">eblas_ddot()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a6ed560fa37afc8e9efabedada3f0601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f380d51545423df4bea1606872b25f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f380d51545423df4bea1606872b25f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a6f380d51545423df4bea1606872b25f5">eblas_dnrm2_gpu</a>&#160;&#160;&#160;cublasDnrm2</td></tr>
<tr class="memdesc:a6f380d51545423df4bea1606872b25f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a465cc13a28dd1b92df1929e386516b3e" title="2-norm of a real array: threaded wrapper to the cblas_dnrm2 BLAS1 function ">eblas_dnrm2()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a6f380d51545423df4bea1606872b25f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f1cf2483a1cf0031f237bb3e50c299"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60f1cf2483a1cf0031f237bb3e50c299"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a60f1cf2483a1cf0031f237bb3e50c299">callPref</a>(functionName)&#160;&#160;&#160;functionName##_gpu</td></tr>
<tr class="memdesc:a60f1cf2483a1cf0031f237bb3e50c299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select between functionName and functionName_gpu for the CPU and GPU executables respectively. <br /></td></tr>
<tr class="separator:a60f1cf2483a1cf0031f237bb3e50c299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a16b2911192a4dd45990e8d3c8749bc3c"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Tx &gt; </td></tr>
<tr class="memitem:a16b2911192a4dd45990e8d3c8749bc3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a16b2911192a4dd45990e8d3c8749bc3c">eblas_mul</a> (const int N, const Tx *X, const int incX, Ty *Y, const int incY)</td></tr>
<tr class="memdesc:a16b2911192a4dd45990e8d3c8749bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated elementwise multiply Y *= X for arrays X, Y.  <a href="#a16b2911192a4dd45990e8d3c8749bc3c">More...</a><br /></td></tr>
<tr class="separator:a16b2911192a4dd45990e8d3c8749bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6379a3d39a315ffa2dcf2c92477741b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6379a3d39a315ffa2dcf2c92477741b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a6379a3d39a315ffa2dcf2c92477741b1">eblas_dmul</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:a6379a3d39a315ffa2dcf2c92477741b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="BlasExtra_8h.html#a16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y. ">eblas_mul()</a> for double[] *= double[]. <br /></td></tr>
<tr class="separator:a6379a3d39a315ffa2dcf2c92477741b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0b6dcdf4b62d7e67e7317502673c20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e0b6dcdf4b62d7e67e7317502673c20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a6e0b6dcdf4b62d7e67e7317502673c20">eblas_zmul</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:a6e0b6dcdf4b62d7e67e7317502673c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="BlasExtra_8h.html#a16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y. ">eblas_mul()</a> for complex[] *= complex[]. <br /></td></tr>
<tr class="separator:a6e0b6dcdf4b62d7e67e7317502673c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2140c951abf8544320da930a0ebd4548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2140c951abf8544320da930a0ebd4548"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a2140c951abf8544320da930a0ebd4548">eblas_zmuld</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:a2140c951abf8544320da930a0ebd4548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="BlasExtra_8h.html#a16b2911192a4dd45990e8d3c8749bc3c" title="Templated elementwise multiply Y *= X for arrays X, Y. ">eblas_mul()</a> for complex[] *= double[]. <br /></td></tr>
<tr class="separator:a2140c951abf8544320da930a0ebd4548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5e834dbcc79293125ffb0aa1b54a5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee5e834dbcc79293125ffb0aa1b54a5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#aee5e834dbcc79293125ffb0aa1b54a5e">eblas_dmul_gpu</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:aee5e834dbcc79293125ffb0aa1b54a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a6379a3d39a315ffa2dcf2c92477741b1" title="Specialization of eblas_mul() for double[] *= double[]. ">eblas_dmul()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:aee5e834dbcc79293125ffb0aa1b54a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef44b279657aad37389393e3f03ed6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ef44b279657aad37389393e3f03ed6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a3ef44b279657aad37389393e3f03ed6d">eblas_zmul_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:a3ef44b279657aad37389393e3f03ed6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a6e0b6dcdf4b62d7e67e7317502673c20" title="Specialization of eblas_mul() for complex[] *= complex[]. ">eblas_zmul()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a3ef44b279657aad37389393e3f03ed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc467ff9f0a44f8eace7f68d5391ccc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc467ff9f0a44f8eace7f68d5391ccc8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#abc467ff9f0a44f8eace7f68d5391ccc8">eblas_zmuld_gpu</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:abc467ff9f0a44f8eace7f68d5391ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a2140c951abf8544320da930a0ebd4548" title="Specialization of eblas_mul() for complex[] *= double[]. ">eblas_zmuld()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:abc467ff9f0a44f8eace7f68d5391ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7f3fb6cf181094d3969a28f2d661f1"><td class="memTemplParams" colspan="2">template&lt;typename Ty , typename Tx &gt; </td></tr>
<tr class="memitem:a8d7f3fb6cf181094d3969a28f2d661f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a8d7f3fb6cf181094d3969a28f2d661f1">eblas_div</a> (const int N, const Tx *X, const int incX, Ty *Y, const int incY)</td></tr>
<tr class="memdesc:a8d7f3fb6cf181094d3969a28f2d661f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated elementwise divide Y /= X for arrays X, Y.  <a href="#a8d7f3fb6cf181094d3969a28f2d661f1">More...</a><br /></td></tr>
<tr class="separator:a8d7f3fb6cf181094d3969a28f2d661f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab632432b443a6e1569bd0d35b2b9d875"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab632432b443a6e1569bd0d35b2b9d875"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#ab632432b443a6e1569bd0d35b2b9d875">eblas_ddiv</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:ab632432b443a6e1569bd0d35b2b9d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="BlasExtra_8h.html#a8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y. ">eblas_div()</a> for double[] /= double[]. <br /></td></tr>
<tr class="separator:ab632432b443a6e1569bd0d35b2b9d875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a317f91a1c555cc4e57686a68fce61a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a317f91a1c555cc4e57686a68fce61a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a5a317f91a1c555cc4e57686a68fce61a">eblas_zdiv</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:a5a317f91a1c555cc4e57686a68fce61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="BlasExtra_8h.html#a8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y. ">eblas_div()</a> for <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well) ...">complex</a>[] /= <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well) ...">complex</a>[]. <br /></td></tr>
<tr class="separator:a5a317f91a1c555cc4e57686a68fce61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1d01b5955a584591c77bf491648d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1d01b5955a584591c77bf491648d10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a4d1d01b5955a584591c77bf491648d10">eblas_zdivd</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:a4d1d01b5955a584591c77bf491648d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="BlasExtra_8h.html#a8d7f3fb6cf181094d3969a28f2d661f1" title="Templated elementwise divide Y /= X for arrays X, Y. ">eblas_div()</a> for <a class="el" href="structcomplex.html" title="Complex number (need to define our own because we need operators for gpu code as well) ...">complex</a>[] /= double[]. <br /></td></tr>
<tr class="separator:a4d1d01b5955a584591c77bf491648d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b56254d2d085b314f397614431d9be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b56254d2d085b314f397614431d9be8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a6b56254d2d085b314f397614431d9be8">eblas_ddiv_gpu</a> (const int N, const double *X, const int incX, double *Y, const int incY)</td></tr>
<tr class="memdesc:a6b56254d2d085b314f397614431d9be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#ab632432b443a6e1569bd0d35b2b9d875" title="Specialization of eblas_div() for double[] /= double[]. ">eblas_ddiv()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a6b56254d2d085b314f397614431d9be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dc7695ae5fa193758cf1dd1167cef2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90dc7695ae5fa193758cf1dd1167cef2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a90dc7695ae5fa193758cf1dd1167cef2">eblas_zdiv_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:a90dc7695ae5fa193758cf1dd1167cef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a5a317f91a1c555cc4e57686a68fce61a" title="Specialization of eblas_div() for complex[] /= complex[]. ">eblas_zdiv()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a90dc7695ae5fa193758cf1dd1167cef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38da349ef7eb56da44c850ce79513abd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38da349ef7eb56da44c850ce79513abd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a38da349ef7eb56da44c850ce79513abd">eblas_zdivd_gpu</a> (const int N, const double *X, const int incX, <a class="el" href="structcomplex.html">complex</a> *Y, const int incY)</td></tr>
<tr class="memdesc:a38da349ef7eb56da44c850ce79513abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a4d1d01b5955a584591c77bf491648d10" title="Specialization of eblas_div() for complex[] /= double[]. ">eblas_zdivd()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a38da349ef7eb56da44c850ce79513abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a77f427ab61421ff49e1a5e3f2e4bd5ab">eblas_lincomb</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> &amp;sX, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, const <a class="el" href="structcomplex.html">complex</a> &amp;sY, const <a class="el" href="structcomplex.html">complex</a> *Y, const int incY, <a class="el" href="structcomplex.html">complex</a> *Z, const int incZ)</td></tr>
<tr class="memdesc:a77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise linear combination Z = sX * X + sY * Y.  <a href="#a77f427ab61421ff49e1a5e3f2e4bd5ab">More...</a><br /></td></tr>
<tr class="separator:a77f427ab61421ff49e1a5e3f2e4bd5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d58c4fae414cd9011e7f50d8943b6fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d58c4fae414cd9011e7f50d8943b6fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a8d58c4fae414cd9011e7f50d8943b6fc">eblas_lincomb_gpu</a> (const int N, const <a class="el" href="structcomplex.html">complex</a> &amp;sX, const <a class="el" href="structcomplex.html">complex</a> *X, const int incX, const <a class="el" href="structcomplex.html">complex</a> &amp;sY, const <a class="el" href="structcomplex.html">complex</a> *Y, const int incY, <a class="el" href="structcomplex.html">complex</a> *Z, const int incZ)</td></tr>
<tr class="memdesc:a8d58c4fae414cd9011e7f50d8943b6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a77f427ab61421ff49e1a5e3f2e4bd5ab" title="Elementwise linear combination Z = sX * X + sY * Y. ">eblas_lincomb()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a8d58c4fae414cd9011e7f50d8943b6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bd2a68d44d54ff9cc6547fcd15baf8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a2bd2a68d44d54ff9cc6547fcd15baf8a">eblas_zgemm</a> (CBLAS_TRANSPOSE TransA, CBLAS_TRANSPOSE TransB, int M, int N, int K, const <a class="el" href="structcomplex.html">complex</a> &amp;alpha, const <a class="el" href="structcomplex.html">complex</a> *A, const int lda, const <a class="el" href="structcomplex.html">complex</a> *B, const int ldb, const <a class="el" href="structcomplex.html">complex</a> &amp;beta, <a class="el" href="structcomplex.html">complex</a> *C, const int ldc)</td></tr>
<tr class="memdesc:a2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threaded complex matrix multiply (threaded wrapper around zgemm) All the parameters have the same meaning as in cblas_zgemm, except element order is always Column Major (FORTRAN order!) <br /></td></tr>
<tr class="separator:a2bd2a68d44d54ff9cc6547fcd15baf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0586fe5f4eadb75205bad2eeaecd224c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0586fe5f4eadb75205bad2eeaecd224c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a0586fe5f4eadb75205bad2eeaecd224c">eblas_zgemm_gpu</a> (CBLAS_TRANSPOSE TransA, CBLAS_TRANSPOSE TransB, int M, int N, int K, const <a class="el" href="structcomplex.html">complex</a> &amp;alpha, const <a class="el" href="structcomplex.html">complex</a> *A, const int lda, const <a class="el" href="structcomplex.html">complex</a> *B, const int ldb, const <a class="el" href="structcomplex.html">complex</a> &amp;beta, <a class="el" href="structcomplex.html">complex</a> *C, const int ldc)</td></tr>
<tr class="memdesc:a0586fe5f4eadb75205bad2eeaecd224c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap cublasZgemm to provide the same interface as <a class="el" href="BlasExtra_8h.html#a2bd2a68d44d54ff9cc6547fcd15baf8a" title="Threaded complex matrix multiply (threaded wrapper around zgemm) All the parameters have the same mea...">eblas_zgemm()</a> <br /></td></tr>
<tr class="separator:a0586fe5f4eadb75205bad2eeaecd224c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476529e0b4f9a1ca010bf370713d9710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a476529e0b4f9a1ca010bf370713d9710">eblas_scatter_zdaxpy</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjugate=false)</td></tr>
<tr class="memdesc:a476529e0b4f9a1ca010bf370713d9710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter y(index) += a * x.  <a href="#a476529e0b4f9a1ca010bf370713d9710">More...</a><br /></td></tr>
<tr class="separator:a476529e0b4f9a1ca010bf370713d9710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2e0b35289f25c758cc8a3486da8810"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b2e0b35289f25c758cc8a3486da8810"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a4b2e0b35289f25c758cc8a3486da8810">eblas_scatter_zaxpy</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjugate=false)</td></tr>
<tr class="memdesc:a4b2e0b35289f25c758cc8a3486da8810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a476529e0b4f9a1ca010bf370713d9710" title="Scatter y(index) += a * x. ">eblas_scatter_zdaxpy()</a> with a complex scale factor. <br /></td></tr>
<tr class="separator:a4b2e0b35289f25c758cc8a3486da8810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa549663109a8a7466af5933873335ff9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa549663109a8a7466af5933873335ff9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#aa549663109a8a7466af5933873335ff9">eblas_scatter_daxpy</a> (const int Nindex, double a, const int *index, const double *x, double *y)</td></tr>
<tr class="memdesc:aa549663109a8a7466af5933873335ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a476529e0b4f9a1ca010bf370713d9710" title="Scatter y(index) += a * x. ">eblas_scatter_zdaxpy()</a> for real data arrays. <br /></td></tr>
<tr class="separator:aa549663109a8a7466af5933873335ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5408c37b12106e66cfdaeb075a2ebf74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a5408c37b12106e66cfdaeb075a2ebf74">eblas_gather_zdaxpy</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjugate=false)</td></tr>
<tr class="memdesc:a5408c37b12106e66cfdaeb075a2ebf74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather y += a * x(index)  <a href="#a5408c37b12106e66cfdaeb075a2ebf74">More...</a><br /></td></tr>
<tr class="separator:a5408c37b12106e66cfdaeb075a2ebf74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7d22b990feb6f4dff0bd57c827e903"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a7d22b990feb6f4dff0bd57c827e903"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a0a7d22b990feb6f4dff0bd57c827e903">eblas_gather_zaxpy</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjugate=false)</td></tr>
<tr class="memdesc:a0a7d22b990feb6f4dff0bd57c827e903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a5408c37b12106e66cfdaeb075a2ebf74" title="Gather y += a * x(index) ">eblas_gather_zdaxpy()</a> with a complex scale factor. <br /></td></tr>
<tr class="separator:a0a7d22b990feb6f4dff0bd57c827e903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b24eba1533dcc5a619aadcc81a5a54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3b24eba1533dcc5a619aadcc81a5a54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#ae3b24eba1533dcc5a619aadcc81a5a54">eblas_gather_daxpy</a> (const int Nindex, double a, const int *index, const double *x, double *y)</td></tr>
<tr class="memdesc:ae3b24eba1533dcc5a619aadcc81a5a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a476529e0b4f9a1ca010bf370713d9710" title="Scatter y(index) += a * x. ">eblas_scatter_zdaxpy()</a> for real data arrays. <br /></td></tr>
<tr class="separator:ae3b24eba1533dcc5a619aadcc81a5a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e922df66bb06a0c6ebfd6440315542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54e922df66bb06a0c6ebfd6440315542"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a54e922df66bb06a0c6ebfd6440315542">eblas_scatter_zdaxpy_gpu</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjugate=false)</td></tr>
<tr class="memdesc:a54e922df66bb06a0c6ebfd6440315542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a476529e0b4f9a1ca010bf370713d9710" title="Scatter y(index) += a * x. ">eblas_scatter_zdaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a54e922df66bb06a0c6ebfd6440315542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53340d2fd662cd2432b533c16ccc2240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53340d2fd662cd2432b533c16ccc2240"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a53340d2fd662cd2432b533c16ccc2240">eblas_scatter_zaxpy_gpu</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjugate=false)</td></tr>
<tr class="memdesc:a53340d2fd662cd2432b533c16ccc2240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a4b2e0b35289f25c758cc8a3486da8810" title="Equivalent of eblas_scatter_zdaxpy() with a complex scale factor. ">eblas_scatter_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a53340d2fd662cd2432b533c16ccc2240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57be18dfc7f2c5213c15effdaadfbba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab57be18dfc7f2c5213c15effdaadfbba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#ab57be18dfc7f2c5213c15effdaadfbba">eblas_scatter_daxpy_gpu</a> (const int Nindex, double a, const int *index, const double *x, double *y)</td></tr>
<tr class="memdesc:ab57be18dfc7f2c5213c15effdaadfbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#aa549663109a8a7466af5933873335ff9" title="Equivalent of eblas_scatter_zdaxpy() for real data arrays. ">eblas_scatter_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ab57be18dfc7f2c5213c15effdaadfbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3750a9f4c1a3d79b7299d234c64f10a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3750a9f4c1a3d79b7299d234c64f10a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#aa3750a9f4c1a3d79b7299d234c64f10a">eblas_gather_zdaxpy_gpu</a> (const int Nindex, double a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjugate=false)</td></tr>
<tr class="memdesc:aa3750a9f4c1a3d79b7299d234c64f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a5408c37b12106e66cfdaeb075a2ebf74" title="Gather y += a * x(index) ">eblas_gather_zdaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:aa3750a9f4c1a3d79b7299d234c64f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27155b455d39d788d09a2dc185a36336"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27155b455d39d788d09a2dc185a36336"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a27155b455d39d788d09a2dc185a36336">eblas_gather_zaxpy_gpu</a> (const int Nindex, <a class="el" href="structcomplex.html">complex</a> a, const int *index, const <a class="el" href="structcomplex.html">complex</a> *x, <a class="el" href="structcomplex.html">complex</a> *y, bool conjugate=false)</td></tr>
<tr class="memdesc:a27155b455d39d788d09a2dc185a36336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a0a7d22b990feb6f4dff0bd57c827e903" title="Equivalent of eblas_gather_zdaxpy() with a complex scale factor. ">eblas_gather_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a27155b455d39d788d09a2dc185a36336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02a9f4d6317d8642d0a8dfcca1fd179"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af02a9f4d6317d8642d0a8dfcca1fd179"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#af02a9f4d6317d8642d0a8dfcca1fd179">eblas_gather_daxpy_gpu</a> (const int Nindex, double a, const int *index, const double *x, double *y)</td></tr>
<tr class="memdesc:af02a9f4d6317d8642d0a8dfcca1fd179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#ae3b24eba1533dcc5a619aadcc81a5a54" title="Equivalent of eblas_scatter_zdaxpy() for real data arrays. ">eblas_gather_daxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:af02a9f4d6317d8642d0a8dfcca1fd179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1b03241b133beaed04728d26a086e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a6c1b03241b133beaed04728d26a086e3">eblas_accumNorm</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, double *y)</td></tr>
<tr class="memdesc:a6c1b03241b133beaed04728d26a086e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x)  <a href="#a6c1b03241b133beaed04728d26a086e3">More...</a><br /></td></tr>
<tr class="separator:a6c1b03241b133beaed04728d26a086e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e140105e5e7ee1f8baaff4e6a016bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a1e140105e5e7ee1f8baaff4e6a016bf5">eblas_accumProd</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, double *yRe, double *yIm)</td></tr>
<tr class="memdesc:a1e140105e5e7ee1f8baaff4e6a016bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and yIm i.e. (yRe + i yIm) += a xU conj(xC)  <a href="#a1e140105e5e7ee1f8baaff4e6a016bf5">More...</a><br /></td></tr>
<tr class="separator:a1e140105e5e7ee1f8baaff4e6a016bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4990759337c29d9752c444b78e3930db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4990759337c29d9752c444b78e3930db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a4990759337c29d9752c444b78e3930db">eblas_accumNorm_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, double *y)</td></tr>
<tr class="memdesc:a4990759337c29d9752c444b78e3930db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a6c1b03241b133beaed04728d26a086e3" title="Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x) ">eblas_accumNorm()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a4990759337c29d9752c444b78e3930db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e99d5e1c919ea332e5232c4ddf7258"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25e99d5e1c919ea332e5232c4ddf7258"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a25e99d5e1c919ea332e5232c4ddf7258">eblas_accumProd_gpu</a> (int N, const double &amp;a, const <a class="el" href="structcomplex.html">complex</a> *xU, const <a class="el" href="structcomplex.html">complex</a> *xC, double *yRe, double *yIm)</td></tr>
<tr class="memdesc:a25e99d5e1c919ea332e5232c4ddf7258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a1e140105e5e7ee1f8baaff4e6a016bf5" title="Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and ...">eblas_accumProd()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a25e99d5e1c919ea332e5232c4ddf7258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2cefdcc0e49ab0781fab0609ef5d74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a9d2cefdcc0e49ab0781fab0609ef5d74">eblas_symmetrize</a> (int N, int n, const int *symmIndex, double *x)</td></tr>
<tr class="memdesc:a9d2cefdcc0e49ab0781fab0609ef5d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize an array x, using N n-fold equivalence classes in symmIndex.  <a href="#a9d2cefdcc0e49ab0781fab0609ef5d74">More...</a><br /></td></tr>
<tr class="separator:a9d2cefdcc0e49ab0781fab0609ef5d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c011b9e8e8f8086690068bcfa7ca92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c011b9e8e8f8086690068bcfa7ca92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#aa0c011b9e8e8f8086690068bcfa7ca92">eblas_symmetrize</a> (int N, int n, const int *symmIndex, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:aa0c011b9e8e8f8086690068bcfa7ca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex. ">eblas_symmetrize()</a> for complex data pointers. <br /></td></tr>
<tr class="separator:aa0c011b9e8e8f8086690068bcfa7ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae81ee89ce9455db6d3a33ed7d85dea5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae81ee89ce9455db6d3a33ed7d85dea5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#aae81ee89ce9455db6d3a33ed7d85dea5">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, double *x)</td></tr>
<tr class="memdesc:aae81ee89ce9455db6d3a33ed7d85dea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex. ">eblas_symmetrize()</a> for real GPU data pointers. <br /></td></tr>
<tr class="separator:aae81ee89ce9455db6d3a33ed7d85dea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a72763dcf3012ff1978f77c9f569ce8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a72763dcf3012ff1978f77c9f569ce8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a5a72763dcf3012ff1978f77c9f569ce8">eblas_symmetrize_gpu</a> (int N, int n, const int *symmIndex, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:a5a72763dcf3012ff1978f77c9f569ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a9d2cefdcc0e49ab0781fab0609ef5d74" title="Symmetrize an array x, using N n-fold equivalence classes in symmIndex. ">eblas_symmetrize()</a> for complex GPU data pointers. <br /></td></tr>
<tr class="separator:a5a72763dcf3012ff1978f77c9f569ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6f244886dd30b195522884c18637f2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e6f244886dd30b195522884c18637f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a3e6f244886dd30b195522884c18637f2">eblas_copy</a> (T *dest, const T *src, int N)</td></tr>
<tr class="memdesc:a3e6f244886dd30b195522884c18637f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a data array.  <a href="#a3e6f244886dd30b195522884c18637f2">More...</a><br /></td></tr>
<tr class="separator:a3e6f244886dd30b195522884c18637f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87de2bde33bddd297cb5eb19013ba06c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a87de2bde33bddd297cb5eb19013ba06c">eblas_zero</a> (int N, double *x)</td></tr>
<tr class="memdesc:a87de2bde33bddd297cb5eb19013ba06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero a data array.  <a href="#a87de2bde33bddd297cb5eb19013ba06c">More...</a><br /></td></tr>
<tr class="separator:a87de2bde33bddd297cb5eb19013ba06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf25460530e534e77f78b6461ea885c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaf25460530e534e77f78b6461ea885c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#adaf25460530e534e77f78b6461ea885c">eblas_zero</a> (int N, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:adaf25460530e534e77f78b6461ea885c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a87de2bde33bddd297cb5eb19013ba06c" title="Zero a data array. ">eblas_zero()</a> for complex data arrays. <br /></td></tr>
<tr class="separator:adaf25460530e534e77f78b6461ea885c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6bba434761869bd04fbd191859cc67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf6bba434761869bd04fbd191859cc67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#aaf6bba434761869bd04fbd191859cc67">eblas_dscal</a> (int N, double a, double *x, int incx)</td></tr>
<tr class="memdesc:aaf6bba434761869bd04fbd191859cc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a real array: threaded wrapper to the cblas_dscal BLAS1 function. <br /></td></tr>
<tr class="separator:aaf6bba434761869bd04fbd191859cc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7106ac749d4593f73b27a119e9486e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7106ac749d4593f73b27a119e9486e6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a7106ac749d4593f73b27a119e9486e6d">eblas_zdscal</a> (int N, double a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:a7106ac749d4593f73b27a119e9486e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a complex array by a real scale factor: threaded wrapper to the cblas_zdscal BLAS1 function. <br /></td></tr>
<tr class="separator:a7106ac749d4593f73b27a119e9486e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7511a88828ad90e98f9e7995813b49be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7511a88828ad90e98f9e7995813b49be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a7511a88828ad90e98f9e7995813b49be">eblas_zscal</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:a7511a88828ad90e98f9e7995813b49be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a complex array by a complex scale factor: threaded wrapper to the cblas_zscal BLAS1 function. <br /></td></tr>
<tr class="separator:a7511a88828ad90e98f9e7995813b49be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad007d0c4eb9fe5c141f9d48bb0dd710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad007d0c4eb9fe5c141f9d48bb0dd710"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#aad007d0c4eb9fe5c141f9d48bb0dd710">eblas_daxpy</a> (int N, double a, const double *x, int incx, double *y, int incy)</td></tr>
<tr class="memdesc:aad007d0c4eb9fe5c141f9d48bb0dd710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled-accumulate on real arrays: threaded wrapper to the cblas_daxpy BLAS1 function. <br /></td></tr>
<tr class="separator:aad007d0c4eb9fe5c141f9d48bb0dd710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bedbfedbae0efdb4b4c1207e36783d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87bedbfedbae0efdb4b4c1207e36783d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a87bedbfedbae0efdb4b4c1207e36783d">eblas_zaxpy</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:a87bedbfedbae0efdb4b4c1207e36783d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled-accumulate on complex arrays: threaded wrapper to the cblas_zaxpy BLAS1 function. <br /></td></tr>
<tr class="separator:a87bedbfedbae0efdb4b4c1207e36783d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafc5a6d2f24e055d3b9d4e36198f706"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afafc5a6d2f24e055d3b9d4e36198f706"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#afafc5a6d2f24e055d3b9d4e36198f706">eblas_zdotc</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, const <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:afafc5a6d2f24e055d3b9d4e36198f706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of complex arrays: threaded wrapper to the cblas_zdotc BLAS1 function. <br /></td></tr>
<tr class="separator:afafc5a6d2f24e055d3b9d4e36198f706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe4a0ee242ac993d41a38f9914dc583"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affe4a0ee242ac993d41a38f9914dc583"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#affe4a0ee242ac993d41a38f9914dc583">eblas_ddot</a> (int N, const double *x, int incx, const double *y, int ncy)</td></tr>
<tr class="memdesc:affe4a0ee242ac993d41a38f9914dc583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of real arrays: threaded wrapper to the cblas_ddot BLAS1 function. <br /></td></tr>
<tr class="separator:affe4a0ee242ac993d41a38f9914dc583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7605fb2b9744d4e1c7de3439cb87cd99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7605fb2b9744d4e1c7de3439cb87cd99"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a7605fb2b9744d4e1c7de3439cb87cd99">eblas_dznrm2</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:a7605fb2b9744d4e1c7de3439cb87cd99"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm of a complex array: threaded wrapper to the cblas_dznrm2 BLAS1 function <br /></td></tr>
<tr class="separator:a7605fb2b9744d4e1c7de3439cb87cd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465cc13a28dd1b92df1929e386516b3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a465cc13a28dd1b92df1929e386516b3e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a465cc13a28dd1b92df1929e386516b3e">eblas_dnrm2</a> (int N, const double *x, int incx)</td></tr>
<tr class="memdesc:a465cc13a28dd1b92df1929e386516b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-norm of a real array: threaded wrapper to the cblas_dnrm2 BLAS1 function <br /></td></tr>
<tr class="separator:a465cc13a28dd1b92df1929e386516b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a702c12a5f0fdc02fa664c20f3fcd4a88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a702c12a5f0fdc02fa664c20f3fcd4a88">eblas_copy_gpu</a> (T *dest, const T *src, int N)</td></tr>
<tr class="memdesc:a702c12a5f0fdc02fa664c20f3fcd4a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a3e6f244886dd30b195522884c18637f2" title="Copy a data array. ">eblas_copy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a702c12a5f0fdc02fa664c20f3fcd4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2c8a30a8ecb57222cefc9a1dba1b6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b2c8a30a8ecb57222cefc9a1dba1b6a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a9b2c8a30a8ecb57222cefc9a1dba1b6a">eblas_zero_gpu</a> (int N, double *x)</td></tr>
<tr class="memdesc:a9b2c8a30a8ecb57222cefc9a1dba1b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a87de2bde33bddd297cb5eb19013ba06c" title="Zero a data array. ">eblas_zero()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a9b2c8a30a8ecb57222cefc9a1dba1b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84f5fd7affb44bb483a1ef58c5a3d3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae84f5fd7affb44bb483a1ef58c5a3d3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#ae84f5fd7affb44bb483a1ef58c5a3d3e">eblas_zero_gpu</a> (int N, <a class="el" href="structcomplex.html">complex</a> *x)</td></tr>
<tr class="memdesc:ae84f5fd7affb44bb483a1ef58c5a3d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a87de2bde33bddd297cb5eb19013ba06c" title="Zero a data array. ">eblas_zero()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ae84f5fd7affb44bb483a1ef58c5a3d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad8f16e4ac5357add3168d9c49ac2fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acad8f16e4ac5357add3168d9c49ac2fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#acad8f16e4ac5357add3168d9c49ac2fa">eblas_zdscal_gpu</a> (int N, double a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:acad8f16e4ac5357add3168d9c49ac2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a7106ac749d4593f73b27a119e9486e6d" title="Scale a complex array by a real scale factor: threaded wrapper to the cblas_zdscal BLAS1 function...">eblas_zdscal()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:acad8f16e4ac5357add3168d9c49ac2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8e8322bf8d0729f1499680e0dfe7cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8e8322bf8d0729f1499680e0dfe7cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a8f8e8322bf8d0729f1499680e0dfe7cb">eblas_zscal_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:a8f8e8322bf8d0729f1499680e0dfe7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of eblas_zscal for GPU data pointers. <br /></td></tr>
<tr class="separator:a8f8e8322bf8d0729f1499680e0dfe7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23131853917b31a47d7fbdd512f9a83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af23131853917b31a47d7fbdd512f9a83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#af23131853917b31a47d7fbdd512f9a83">eblas_zaxpy_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> &amp;a, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:af23131853917b31a47d7fbdd512f9a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a87bedbfedbae0efdb4b4c1207e36783d" title="Scaled-accumulate on complex arrays: threaded wrapper to the cblas_zaxpy BLAS1 function. ">eblas_zaxpy()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:af23131853917b31a47d7fbdd512f9a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278331b2acb3b0e598b4cc108c8c202e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a278331b2acb3b0e598b4cc108c8c202e"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a278331b2acb3b0e598b4cc108c8c202e">eblas_zdotc_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx, const <a class="el" href="structcomplex.html">complex</a> *y, int incy)</td></tr>
<tr class="memdesc:a278331b2acb3b0e598b4cc108c8c202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#afafc5a6d2f24e055d3b9d4e36198f706" title="Dot product of complex arrays: threaded wrapper to the cblas_zdotc BLAS1 function. ">eblas_zdotc()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:a278331b2acb3b0e598b4cc108c8c202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71862f9e023ce0f62601f0ea5222b81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab71862f9e023ce0f62601f0ea5222b81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#ab71862f9e023ce0f62601f0ea5222b81">eblas_dznrm2_gpu</a> (int N, const <a class="el" href="structcomplex.html">complex</a> *x, int incx)</td></tr>
<tr class="memdesc:ab71862f9e023ce0f62601f0ea5222b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a7605fb2b9744d4e1c7de3439cb87cd99" title="2-norm of a complex array: threaded wrapper to the cblas_dznrm2 BLAS1 function ">eblas_dznrm2()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ab71862f9e023ce0f62601f0ea5222b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53707938a6bc21c6e01f719a3fe51f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#a53707938a6bc21c6e01f719a3fe51f30">eblas_capMinMax</a> (const int N, double *x, double &amp;xMin, double &amp;xMax, double capLo=-DBL_MAX, double capHi=+DBL_MAX)</td></tr>
<tr class="memdesc:a53707938a6bc21c6e01f719a3fe51f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum and maximum of a data array and optionally cap it from above and/or below.  <a href="#a53707938a6bc21c6e01f719a3fe51f30">More...</a><br /></td></tr>
<tr class="separator:a53707938a6bc21c6e01f719a3fe51f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae479c614697e16892fe5554f68f3882f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae479c614697e16892fe5554f68f3882f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="BlasExtra_8h.html#ae479c614697e16892fe5554f68f3882f">eblas_capMinMax_gpu</a> (const int N, double *x, double &amp;xMin, double &amp;xMax, double capLo=-DBL_MAX, double capHi=+DBL_MAX)</td></tr>
<tr class="memdesc:ae479c614697e16892fe5554f68f3882f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent of <a class="el" href="BlasExtra_8h.html#a53707938a6bc21c6e01f719a3fe51f30" title="Find the minimum and maximum of a data array and optionally cap it from above and/or below...">eblas_capMinMax()</a> for GPU data pointers. <br /></td></tr>
<tr class="separator:ae479c614697e16892fe5554f68f3882f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Commonly used BLAS-like routines. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6c1b03241b133beaed04728d26a086e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_accumNorm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate elementwise norm of a complex array x into y i.e. y += a x conj(x) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array </td></tr>
    <tr><td class="paramname">a</td><td>scale factor </td></tr>
    <tr><td class="paramname">x</td><td>Input complex data array </td></tr>
    <tr><td class="paramname">y</td><td>Ouput real data array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e140105e5e7ee1f8baaff4e6a016bf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_accumProd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>xU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>xC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>yRe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>yIm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate elementwise product of two complex arrays xU and xC into real and imaginary parts yRe and yIm i.e. (yRe + i yIm) += a xU conj(xC) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array </td></tr>
    <tr><td class="paramname">a</td><td>scale factor </td></tr>
    <tr><td class="paramname">xU</td><td>Unconjugated input complex data array </td></tr>
    <tr><td class="paramname">xC</td><td>Conjugated input complex data array </td></tr>
    <tr><td class="paramname">yRe</td><td>Ouput real-part data array </td></tr>
    <tr><td class="paramname">yIm</td><td>Ouput imaginary-part data array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53707938a6bc21c6e01f719a3fe51f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_capMinMax </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>xMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>capLo</em> = <code>-DBL_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>capHi</em> = <code>+DBL_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum and maximum of a data array and optionally cap it from above and/or below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of data array </td></tr>
    <tr><td class="paramname">x</td><td>Input data array, that might be modified if capLo or capHi are finite </td></tr>
    <tr><td class="paramname">xMin</td><td>On output, the minimum of the input data array </td></tr>
    <tr><td class="paramname">xMax</td><td>On output, the maximum of the input data array </td></tr>
    <tr><td class="paramname">capLo</td><td>If finite, cap the data array on output from below at this value (no capping for the default value) </td></tr>
    <tr><td class="paramname">capHi</td><td>If finite, cap the data array on output from above at this value (no capping for the default value) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e6f244886dd30b195522884c18637f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void eblas_copy </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a data array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type of the input and output arrays </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Destination data pointer </td></tr>
    <tr><td class="paramname">src</td><td>Source data pointer </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements of the data type T to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d7f3fb6cf181094d3969a28f2d661f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty , typename Tx &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void eblas_div </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ty *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated elementwise divide Y /= X for arrays X, Y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ty</td><td>primiitive data-type for array Y </td></tr>
    <tr><td class="paramname">Tx</td><td>primiitive data-type for array X </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>number of elements in X and Y </td></tr>
    <tr><td class="paramname">X</td><td>pointer to the first element of array X </td></tr>
    <tr><td class="paramname">incX</td><td>stride along the X array </td></tr>
    <tr><td class="paramname">Y</td><td>pointer to the first element of array Y </td></tr>
    <tr><td class="paramname">incY</td><td>stride along the Y array (must be non-zero) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5408c37b12106e66cfdaeb075a2ebf74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_gather_zdaxpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Nindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjugate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather y += a * x(index) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nindex</td><td>Length of index array </td></tr>
    <tr><td class="paramname">a</td><td>Scale factor (real) </td></tr>
    <tr><td class="paramname">index</td><td>0-based index array (with length at least Nindex) </td></tr>
    <tr><td class="paramname">x</td><td>Input array that is sampled with the index array (with length at least max(index)+1) </td></tr>
    <tr><td class="paramname">y</td><td>Output array that is sampled consecutively (with length at least Nindex) </td></tr>
    <tr><td class="paramname">conjugate</td><td>If true, accumulate from conj(x) instead of x </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77f427ab61421ff49e1a5e3f2e4bd5ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_lincomb </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> &amp;&#160;</td>
          <td class="paramname"><em>sX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> &amp;&#160;</td>
          <td class="paramname"><em>sY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise linear combination Z = sX * X + sY * Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Number of elements in X, Y and X </td></tr>
    <tr><td class="paramname">sX</td><td>Scale factor for input X </td></tr>
    <tr><td class="paramname">X</td><td>Data pointer for input X </td></tr>
    <tr><td class="paramname">incX</td><td>Pointer increment for input X </td></tr>
    <tr><td class="paramname">sY</td><td>Scale factor for input Y </td></tr>
    <tr><td class="paramname">Y</td><td>Data pointer for input Y </td></tr>
    <tr><td class="paramname">incY</td><td>Pointer increment for input Y </td></tr>
    <tr><td class="paramname">Z</td><td>Data pointer for input Z </td></tr>
    <tr><td class="paramname">incZ</td><td>Pointer increment for input Z </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16b2911192a4dd45990e8d3c8749bc3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ty , typename Tx &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void eblas_mul </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ty *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>incY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated elementwise multiply Y *= X for arrays X, Y. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ty</td><td>primiitive data-type for array Y </td></tr>
    <tr><td class="paramname">Tx</td><td>primiitive data-type for array X </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>number of elements in X and Y </td></tr>
    <tr><td class="paramname">X</td><td>pointer to the first element of array X </td></tr>
    <tr><td class="paramname">incX</td><td>stride along the X array </td></tr>
    <tr><td class="paramname">Y</td><td>pointer to the first element of array Y </td></tr>
    <tr><td class="paramname">incY</td><td>stride along the Y array (must be non-zero) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a476529e0b4f9a1ca010bf370713d9710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_scatter_zdaxpy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>Nindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjugate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatter y(index) += a * x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nindex</td><td>Length of index array </td></tr>
    <tr><td class="paramname">a</td><td>Scale factor (real) </td></tr>
    <tr><td class="paramname">index</td><td>0-based index array (with length at least Nindex) </td></tr>
    <tr><td class="paramname">x</td><td>Input array that is sampled consecutively (with length at least Nindex) </td></tr>
    <tr><td class="paramname">y</td><td>Output array that is sampled with the index array (with length at least max(index)+1) </td></tr>
    <tr><td class="paramname">conjugate</td><td>If true, accumulate from conj(x) instead of x </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d2cefdcc0e49ab0781fab0609ef5d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_symmetrize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>symmIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrize an array x, using N n-fold equivalence classes in symmIndex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Length of array x </td></tr>
    <tr><td class="paramname">n</td><td>Length of symmetry equivalence classes </td></tr>
    <tr><td class="paramname">symmIndex</td><td>Every consecutive set of n indices in this array forms an equivalence class </td></tr>
    <tr><td class="paramname">x</td><td>Data array to be symmetrized in place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87de2bde33bddd297cb5eb19013ba06c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eblas_zero </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero a data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Number of elements to zero </td></tr>
    <tr><td class="paramname">x</td><td>Data pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li><li class="navelem"><a class="el" href="BlasExtra_8h.html">BlasExtra.h</a></li>
    <li class="footer">Generated on Thu Jan 26 2017 12:59:22 for JDFTx by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
