<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>JDFTx: electronic/operators.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="jdftx-55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JDFTx
   &#160;<span id="projectnumber">1.1.2</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('operators_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">operators.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Operators specific to the electronic code.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;electronic/common.h&gt;</code><br />
<code>#include &lt;electronic/RadialFunction.h&gt;</code><br />
<code>#include &lt;<a class="el" href="VectorField_8h_source.html">core/VectorField.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ScalarFieldArray_8h_source.html">core/ScalarFieldArray.h</a>&gt;</code><br />
<code>#include &lt;core/matrix3.h&gt;</code><br />
</div>
<p><a href="operators_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab3b8ee5929a836d73ccf24bb582c46ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#ab3b8ee5929a836d73ccf24bb582c46ef">removePhase</a> (size_t N, <a class="el" href="structcomplex.html">complex</a> *data, double &amp;meanPhase, double &amp;sigmaPhase, double &amp;rmsImagErr)</td></tr>
<tr class="separator:ab3b8ee5929a836d73ccf24bb582c46ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cb5c0efe834a7b4739215a370ae060"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92cb5c0efe834a7b4739215a370ae060"></a>
<a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a92cb5c0efe834a7b4739215a370ae060">D</a> (const <a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, int iDir)</td></tr>
<tr class="memdesc:a92cb5c0efe834a7b4739215a370ae060"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the gradient in the iDir'th cartesian direction <br /></td></tr>
<tr class="separator:a92cb5c0efe834a7b4739215a370ae060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d276a3c8ef8d18156c549d42258b25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09d276a3c8ef8d18156c549d42258b25"></a>
<a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a09d276a3c8ef8d18156c549d42258b25">DD</a> (const <a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, int iDir, int jDir)</td></tr>
<tr class="memdesc:a09d276a3c8ef8d18156c549d42258b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">second derivative along iDir'th and jDir'th cartesian directions <br /></td></tr>
<tr class="separator:a09d276a3c8ef8d18156c549d42258b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af783a0aec720d55e34f5ba4727718ee9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af783a0aec720d55e34f5ba4727718ee9"></a>
<a class="el" href="ScalarFieldArray_8h.html#a8d907909fee035ff906972703c7bb870">ScalarFieldTildeArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#af783a0aec720d55e34f5ba4727718ee9">lGradient</a> (const <a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;, int l)</td></tr>
<tr class="memdesc:af783a0aec720d55e34f5ba4727718ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">spherical tensor gradient of order l (2l+1 outputs, multiplied by Ylm(Ghat) (iG)^l) <br /></td></tr>
<tr class="separator:af783a0aec720d55e34f5ba4727718ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669c9ca358fcf20b5040d3230c47f1fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a669c9ca358fcf20b5040d3230c47f1fd"></a>
<a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a669c9ca358fcf20b5040d3230c47f1fd">lDivergence</a> (const <a class="el" href="ScalarFieldArray_8h.html#a8d907909fee035ff906972703c7bb870">ScalarFieldTildeArray</a> &amp;, int l)</td></tr>
<tr class="memdesc:a669c9ca358fcf20b5040d3230c47f1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">spherical tensor divergence of order l (2l+1 inputs, multiplied by Ylm(Ghat) (iG)^l, and summed) <br /></td></tr>
<tr class="separator:a669c9ca358fcf20b5040d3230c47f1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79546ba0d7ac12699a7052cd9078062b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79546ba0d7ac12699a7052cd9078062b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a79546ba0d7ac12699a7052cd9078062b">multiplyBlochPhase</a> (<a class="el" href="group__griddata.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, const <a class="el" href="classvector3.html">vector3</a>&lt;&gt; &amp;k)</td></tr>
<tr class="memdesc:a79546ba0d7ac12699a7052cd9078062b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply complex scalar field by Block phase for wave-vector k (in reciprocal lattice coordinates) <br /></td></tr>
<tr class="separator:a79546ba0d7ac12699a7052cd9078062b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c35870825f843c1800f61bb42f923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a7a0c35870825f843c1800f61bb42f923">pointGroupGather</a> (const <a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, const <a class="el" href="classmatrix3.html">matrix3</a>&lt; int &gt; &amp;mMesh)</td></tr>
<tr class="separator:a7a0c35870825f843c1800f61bb42f923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ec69a3a1a8e022a9c0c23d5c4fbdba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9ec69a3a1a8e022a9c0c23d5c4fbdba"></a>
<a class="el" href="group__griddata.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pointGroupGather</b> (const <a class="el" href="group__griddata.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, const <a class="el" href="classmatrix3.html">matrix3</a>&lt; int &gt; &amp;mMesh)</td></tr>
<tr class="separator:ab9ec69a3a1a8e022a9c0c23d5c4fbdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae228958d2fe553140e1ab9119002cf84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#ae228958d2fe553140e1ab9119002cf84">pointGroupScatter</a> (const <a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;, const <a class="el" href="classmatrix3.html">matrix3</a>&lt; int &gt; &amp;mMesh)</td></tr>
<tr class="separator:ae228958d2fe553140e1ab9119002cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa990cc0cf78f349fa1ff9b2bdb03146a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa990cc0cf78f349fa1ff9b2bdb03146a"></a>
<a class="el" href="group__griddata.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pointGroupScatter</b> (const <a class="el" href="group__griddata.html#ga0a122002c764801a8923fd2091efcd0b">complexScalarField</a> &amp;, const <a class="el" href="classmatrix3.html">matrix3</a>&lt; int &gt; &amp;mMesh)</td></tr>
<tr class="separator:aa990cc0cf78f349fa1ff9b2bdb03146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1abe1e7e20e216cc53c873e4859351d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1abe1e7e20e216cc53c873e4859351d"></a>
<a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#ab1abe1e7e20e216cc53c873e4859351d">radialFunction</a> (const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfo, const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;f, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; r0)</td></tr>
<tr class="memdesc:ab1abe1e7e20e216cc53c873e4859351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a spherically symmetric real scalar field centered at lattice coordinates r0, given its radial fourier transform f. <br /></td></tr>
<tr class="separator:ab1abe1e7e20e216cc53c873e4859351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad6e4116d1e13ad56d8db567923fe53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ad6e4116d1e13ad56d8db567923fe53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a0ad6e4116d1e13ad56d8db567923fe53">radialFunctionG</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;f, <a class="el" href="structRealKernel.html">RealKernel</a> &amp;Kernel)</td></tr>
<tr class="memdesc:a0ad6e4116d1e13ad56d8db567923fe53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a spherically symmetric scalar G-space kernel given its radial form f. <br /></td></tr>
<tr class="separator:a0ad6e4116d1e13ad56d8db567923fe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863b1f8ec326f0263724a0c948a034fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a863b1f8ec326f0263724a0c948a034fa"></a>
<a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a863b1f8ec326f0263724a0c948a034fa">radialFunctionG</a> (const <a class="el" href="classGridInfo.html">GridInfo</a> &amp;gInfo, const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;f, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; r0)</td></tr>
<tr class="memdesc:a863b1f8ec326f0263724a0c948a034fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a spherically symmetric G-space scalar field centered at lattice coordinates r0 given its radial form f. <br /></td></tr>
<tr class="separator:a863b1f8ec326f0263724a0c948a034fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaea7b606153eb02bd60810b06e6883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaaea7b606153eb02bd60810b06e6883"></a>
<a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#aeaaea7b606153eb02bd60810b06e6883">operator*</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;, const <a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:aeaaea7b606153eb02bd60810b06e6883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a scalar field by a radial function (preserve input) <br /></td></tr>
<tr class="separator:aeaaea7b606153eb02bd60810b06e6883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159ffca6ee0dd5c16fd2a36fbdaa2a2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a159ffca6ee0dd5c16fd2a36fbdaa2a2a"></a>
<a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a159ffca6ee0dd5c16fd2a36fbdaa2a2a">operator*</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;, <a class="el" href="group__griddata.html#ga6e08b08fea5bf3bca91972c6e49d4547">ScalarFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a159ffca6ee0dd5c16fd2a36fbdaa2a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a scalar field by a radial function (destructible input) <br /></td></tr>
<tr class="separator:a159ffca6ee0dd5c16fd2a36fbdaa2a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c02c0a54ff6df6b5a5677fa135788e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76c02c0a54ff6df6b5a5677fa135788e"></a>
<a class="el" href="group__griddata.html#ga73cd3c9d300acd482ff8327ce2415a6c">VectorFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a76c02c0a54ff6df6b5a5677fa135788e">operator*</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;, const <a class="el" href="group__griddata.html#ga73cd3c9d300acd482ff8327ce2415a6c">VectorFieldTilde</a> &amp;)</td></tr>
<tr class="memdesc:a76c02c0a54ff6df6b5a5677fa135788e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a vector field by a radial function (preserve input) <br /></td></tr>
<tr class="separator:a76c02c0a54ff6df6b5a5677fa135788e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1480e3eb4c5c6c7bb0295ffdf5229591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1480e3eb4c5c6c7bb0295ffdf5229591"></a>
<a class="el" href="group__griddata.html#ga73cd3c9d300acd482ff8327ce2415a6c">VectorFieldTilde</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a1480e3eb4c5c6c7bb0295ffdf5229591">operator*</a> (const <a class="el" href="structRadialFunctionG.html">RadialFunctionG</a> &amp;, <a class="el" href="group__griddata.html#ga73cd3c9d300acd482ff8327ce2415a6c">VectorFieldTilde</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a1480e3eb4c5c6c7bb0295ffdf5229591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a vector field by a radial function (destructible input) <br /></td></tr>
<tr class="separator:a1480e3eb4c5c6c7bb0295ffdf5229591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae191889c0b98fc1d935678ea22c0b93c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#ae191889c0b98fc1d935678ea22c0b93c">Idag_DiagV_I</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;C, const <a class="el" href="ScalarFieldArray_8h.html#a76a7258e8ec5efe14ca37d36fc98554c">ScalarFieldArray</a> &amp;V)</td></tr>
<tr class="separator:ae191889c0b98fc1d935678ea22c0b93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d4d30b7062edfd0f75a082814c3067"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6d4d30b7062edfd0f75a082814c3067"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#af6d4d30b7062edfd0f75a082814c3067">L</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y)</td></tr>
<tr class="memdesc:af6d4d30b7062edfd0f75a082814c3067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Laplacian. <br /></td></tr>
<tr class="separator:af6d4d30b7062edfd0f75a082814c3067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20720de21af94d24497310b259876d2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20720de21af94d24497310b259876d2a"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a20720de21af94d24497310b259876d2a">Linv</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y)</td></tr>
<tr class="memdesc:a20720de21af94d24497310b259876d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply Laplacian inverse. <br /></td></tr>
<tr class="separator:a20720de21af94d24497310b259876d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4597f9dccad3baeb8f90d0986b15dade"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4597f9dccad3baeb8f90d0986b15dade"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a4597f9dccad3baeb8f90d0986b15dade">O</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y, std::vector&lt; <a class="el" href="classmatrix.html">matrix</a> &gt; *VdagY=0)</td></tr>
<tr class="memdesc:a4597f9dccad3baeb8f90d0986b15dade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply overlap (and optionally retrieve pseudopotential projections for later reuse) <br /></td></tr>
<tr class="separator:a4597f9dccad3baeb8f90d0986b15dade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed74fe1efd5d6a3593b8db2e422643c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ed74fe1efd5d6a3593b8db2e422643c"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a7ed74fe1efd5d6a3593b8db2e422643c">D</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y, int iDir)</td></tr>
<tr class="memdesc:a7ed74fe1efd5d6a3593b8db2e422643c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cartesian gradient of a column bundle in direction# iDir. <br /></td></tr>
<tr class="separator:a7ed74fe1efd5d6a3593b8db2e422643c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1aa6b1760cd88c94c5437460d02974"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b1aa6b1760cd88c94c5437460d02974"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a9b1aa6b1760cd88c94c5437460d02974">DD</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y, int iDir, int jDir)</td></tr>
<tr class="memdesc:a9b1aa6b1760cd88c94c5437460d02974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute second spatial derivative of a column bundle along directions# iDir, jDir. <br /></td></tr>
<tr class="separator:a9b1aa6b1760cd88c94c5437460d02974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e43582f8dd2d01f3e678943daa2a9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41e43582f8dd2d01f3e678943daa2a9f"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a41e43582f8dd2d01f3e678943daa2a9f">precond_inv_kinetic</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y, double KErollover)</td></tr>
<tr class="memdesc:a41e43582f8dd2d01f3e678943daa2a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply inverse kinetic preconditioner inv((k+G)^2/2) <br /></td></tr>
<tr class="separator:a41e43582f8dd2d01f3e678943daa2a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a00802e4e875034fd6a161c6da0711a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a00802e4e875034fd6a161c6da0711a"></a>
<a class="el" href="classdiagMatrix.html">diagMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a6a00802e4e875034fd6a161c6da0711a">diagDot</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;X, const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y)</td></tr>
<tr class="memdesc:a6a00802e4e875034fd6a161c6da0711a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute diag(X^Y) efficiently (avoid the off-diagonals) <br /></td></tr>
<tr class="separator:a6a00802e4e875034fd6a161c6da0711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace29b86767491a48256e630ddf1987ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace29b86767491a48256e630ddf1987ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#ace29b86767491a48256e630ddf1987ee">precond_inv_kinetic_band</a> (<a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y, const <a class="el" href="classdiagMatrix.html">diagMatrix</a> &amp;KEref)</td></tr>
<tr class="memdesc:ace29b86767491a48256e630ddf1987ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place inverse kinetic preconditioner with band-by-band KE reference (Used by <a class="el" href="classBandDavidson.html">BandDavidson</a>) <br /></td></tr>
<tr class="separator:ace29b86767491a48256e630ddf1987ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ec8dabcaa967f5e4b9304d3a09ae40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8ec8dabcaa967f5e4b9304d3a09ae40"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#aa8ec8dabcaa967f5e4b9304d3a09ae40">translate</a> (<a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;&amp;, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; dr)</td></tr>
<tr class="memdesc:aa8ec8dabcaa967f5e4b9304d3a09ae40"><td class="mdescLeft">&#160;</td><td class="mdescRight">translate a column-bundle by dr in lattice coordinates (destructible input) <br /></td></tr>
<tr class="separator:aa8ec8dabcaa967f5e4b9304d3a09ae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1281b30e04ec70a4c9cd0fff1cc145be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1281b30e04ec70a4c9cd0fff1cc145be"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a1281b30e04ec70a4c9cd0fff1cc145be">translate</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;, <a class="el" href="classvector3.html">vector3</a>&lt;&gt; dr)</td></tr>
<tr class="memdesc:a1281b30e04ec70a4c9cd0fff1cc145be"><td class="mdescLeft">&#160;</td><td class="mdescRight">translate a column-bundle by dr in lattice coordinates (preserve input) <br /></td></tr>
<tr class="separator:a1281b30e04ec70a4c9cd0fff1cc145be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45659650b6bb083aabae792b10d2507"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad45659650b6bb083aabae792b10d2507"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#ad45659650b6bb083aabae792b10d2507">translateColumns</a> (<a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;, const <a class="el" href="classvector3.html">vector3</a>&lt;&gt; *dr)</td></tr>
<tr class="memdesc:ad45659650b6bb083aabae792b10d2507"><td class="mdescLeft">&#160;</td><td class="mdescRight">translate each column of a column bundle by a different dr (in-place) <br /></td></tr>
<tr class="separator:ad45659650b6bb083aabae792b10d2507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87862f94df4798ea5228ba9508aa598d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87862f94df4798ea5228ba9508aa598d"></a>
<a class="el" href="classColumnBundle.html">ColumnBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#a87862f94df4798ea5228ba9508aa598d">switchBasis</a> (const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;, const <a class="el" href="classBasis.html">Basis</a> &amp;)</td></tr>
<tr class="memdesc:a87862f94df4798ea5228ba9508aa598d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return wavefunction projected to a different basis <br /></td></tr>
<tr class="separator:a87862f94df4798ea5228ba9508aa598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa738ca3a7d2d3d6aac2c10fda8c7212c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa738ca3a7d2d3d6aac2c10fda8c7212c"></a>
<a class="el" href="structcomplex.html">complex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#aa738ca3a7d2d3d6aac2c10fda8c7212c">traceinner</a> (const <a class="el" href="classdiagMatrix.html">diagMatrix</a> &amp;F, const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;X, const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;Y)</td></tr>
<tr class="memdesc:aa738ca3a7d2d3d6aac2c10fda8c7212c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return trace(F*X^Y) <br /></td></tr>
<tr class="separator:aa738ca3a7d2d3d6aac2c10fda8c7212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad788864d7bc82045338671fae87ae4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ScalarFieldArray_8h.html#a76a7258e8ec5efe14ca37d36fc98554c">ScalarFieldArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="operators_8h.html#ad788864d7bc82045338671fae87ae4f7">diagouterI</a> (const <a class="el" href="classdiagMatrix.html">diagMatrix</a> &amp;F, const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;X, int nDensities, const <a class="el" href="classGridInfo.html">GridInfo</a> *gInfoOut=0)</td></tr>
<tr class="separator:ad788864d7bc82045338671fae87ae4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Operators specific to the electronic code. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad788864d7bc82045338671fae87ae4f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ScalarFieldArray_8h.html#a76a7258e8ec5efe14ca37d36fc98554c">ScalarFieldArray</a> diagouterI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdiagMatrix.html">diagMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDensities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridInfo.html">GridInfo</a> *&#160;</td>
          <td class="paramname"><em>gInfoOut</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns diag((I*X)*F*(I*X)^) (Compute density from an orthonormal wavefunction <a class="el" href="classColumnBundle.html">ColumnBundle</a> with some fillings F). nDensities is the number of scalar field in the output and controls how spin/spinors are handled: 1: return total density regardless of spin / spinor nature 2: return spin density in X.qnum-&gt;index()'th component of the output (valid for non-spinor X only) 4: return spin density-matrix (valid for spinor X only) If gInfoOut is specified, function ensures that the output is changed to that grid (in case tighter wfns grid is in use) </p>

</div>
</div>
<a class="anchor" id="ae191889c0b98fc1d935678ea22c0b93c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classColumnBundle.html">ColumnBundle</a> Idag_DiagV_I </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classColumnBundle.html">ColumnBundle</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ScalarFieldArray_8h.html#a76a7258e8ec5efe14ca37d36fc98554c">ScalarFieldArray</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return Idag V .* I C (evaluated columnwise) The handling of the spin structure of V parallels that of diagouterI, with V.size() taking the role of nDensities </p>

</div>
</div>
<a class="anchor" id="a7a0c35870825f843c1800f61bb42f923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> pointGroupGather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmatrix3.html">matrix3</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resample scalar field by gathering from coordinates rotated by point group element specified in mesh coordinates. Hermitian conjugate of pointGroupScatter </p>

</div>
</div>
<a class="anchor" id="ae228958d2fe553140e1ab9119002cf84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> pointGroupScatter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__griddata.html#gaba3dacad6ffc23d9625d87ea805b2bd9">ScalarField</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmatrix3.html">matrix3</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resample scalar field by scattering to coordinates rotated by point group element specified in mesh coordinates. Hermitian conjugate of pointGroupGather </p>

</div>
</div>
<a class="anchor" id="ab3b8ee5929a836d73ccf24bb582c46ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removePhase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>meanPhase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigmaPhase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>rmsImagErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a complex wavefunction to a real one with optimum phase choice Store the phase statistics before conversion in meanPhase and sigmaPhase and the relative rms imaginary part truncated during conversion in rmsImagErr (Useful for getting real wavefunctions in gamma point only calculations or <a class="el" href="classWannier.html" title="Compute Maximally-Localized Wannier Functions. ">Wannier</a> functions) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_fb14a786583251f601b9ef38383b6929.html">electronic</a></li><li class="navelem"><a class="el" href="operators_8h.html">operators.h</a></li>
    <li class="footer">Generated on Thu Jan 26 2017 12:59:22 for JDFTx by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
