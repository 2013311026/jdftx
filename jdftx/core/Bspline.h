/*-------------------------------------------------------------------
Copyright 2011 Ravishankar Sundararaman

This file is part of JDFTx.

JDFTx is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

JDFTx is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with JDFTx.  If not, see <http://www.gnu.org/licenses/>.
-------------------------------------------------------------------*/

#ifndef JDFTX_CORE_BSPLINE_H
#define JDFTX_CORE_BSPLINE_H

//! @addtogroup excessfunctionals
//! @{

//! @file Bspline.h
//! @brief Fast Bezier spline lookup table

#include <cstdio>
#include <vector>
#include <core/scalar.h>

//! Wraps a cubic Bezier spline lookup table around function and derivative evaluations
class Bspline
{
protected:
	virtual double getValue(double)=0; //!< Function that needs to be converted to a lookup table (must implement in derived class)
	virtual double getDeriv(double)=0; //!< Derivative of the function that needs to be converted to a lookup table (must implement in derived class)
public:
	//! Initialize the lookup table to cover [xStart:xEnd)
	//! (getValue and getDeriv will get called outside this range)
	Bspline(double xStart, double xEnd, int nIntervals);
	~Bspline();

	void init(); //!< Initialize the cubic spline coefficients based on getValue() and getDeriv()

	//! Print a report on estimated max errors in function and deriv due to interpolation to stream fp.
	//! If plotFileName is provided, a 3 column data [x getValue(x) value(x)] for x in [xStart xEnd] will be printed to it
	void maxErrorEstimate(FILE* fp, const char* plotFileName=0);

	inline double value(double x); //!< Calculate function using lookup table
	inline double deriv(double x); //!< Calculate derivative using lookup table
	inline void value_deriv(double x, double& value, double& deriv); //!< Calculate function and derivative using lookup table
private:
	int nCoeff;
	double xStart, h, invh;
	double* coeff;
};

namespace QuinticSpline
{
	//! Generate quintic spline coefficients for a set of uniformly-spaced samples
	//! The boundary condition at the first sample is odd/even for oddExtension=true/false respectively.
	//! Natural boundary conditions (third and fourth derivatives zero) are imposed on the last sample.
	std::vector<double> getCoeff(const std::vector<double>& samples, bool oddExtension=false);
	
	//! Compute value of quintic spline (Warning: x is not range-checked)
	//! @param coeff pointer to coefficient array generated by getCoeff
	//! @param x location to evaluate spline in the continuous range [0, nCoeff-1)
	__hostanddev__ double value(const double* coeff, double x);
	
	//! Compute derivative (w.r.t x) of quintic spline (Warning: x is not range-checked)
	//! @param coeff pointer to coefficient array generated by getCoeff
	//! @param x location to evaluate spline in the continuous range [0, nCoeff-1)
	__hostanddev__ double deriv(const double* coeff, double x);
	
	//! Gradient propagation corresponding to value calculation above
	__hostanddev__ void valueGrad(double E_value, double* E_coeff, double x);
	
}

//! @}

//###################################################################################################
//####  Implementation  ####
//##########################
//!@cond


#include <cmath>

inline double Bspline::value(double x)
{	register double t = invh*(x-xStart);
	register int it = floor(t);
	if(it<0 || it>=nCoeff) return getValue(x);
	register double* a = coeff + 4*it;
	t -= it;
	return a[0] + t*(a[1] + t*(a[2] + t*a[3]));
}

inline double Bspline::deriv(double x)
{	register double t = invh*(x-xStart);
	register int it = floor(t);
	if(it<0 || it>=nCoeff) return getDeriv(x);
	register double* a = coeff + 4*it;
	t -= it;
	return invh*(a[1] + t*(2.0*a[2] + t*3.0*a[3]));
}

inline void Bspline::value_deriv(double x, double& value, double& deriv)
{	register double t = invh*(x-xStart);
	register int it = floor(t);
	if(it<0 || it>=nCoeff) { value=getValue(x); deriv=getDeriv(x); return; }
	register double* a = coeff + 4*it;
	t -= it;
	value = a[0] + t*(a[1] + t*(a[2] + t*a[3]));
	deriv = invh*(a[1] + t*(2.0*a[2] + t*3.0*a[3]));
}

namespace QuinticSpline
{
	__hostanddev__ void getBernsteinCoeffs(const double* coeff, double x, double& tR, double& tL, double (&b)[6])
	{	int j = (int)x;
		tR = x - j; //right weight for interval
		tL = 1.-tR; //left weight for interval
		//Load blip coefficients:
		double c[6];
		for(int i=0; i<6; i++) c[i] = coeff[j+i];
		//Convert to Bernstein polynomial coefficients:
		b[0] = (1./66) * (c[0] + 26*c[1] + 66*c[2] + 26*c[3] + c[4]);
		b[1] = (1./33) * (8*c[1] + 33*c[2] + 18*c[3] + c[4]);
		b[2] = (2./33) * (2*c[1] + 15*c[2] + 12*c[3] + c[4]);
		b[3] = (2./33) * (c[1] + 12*c[2] + 15*c[3] + 2*c[4]);
		b[4] = (1./33) * (c[1] + 18*c[2] + 33*c[3] + 8*c[4]);
		b[5] = (1./66) * (c[1] + 26*c[2] + 66*c[3] + 26*c[4] + c[5]);
	}
	
	//Compute value of quintic spline
	__hostanddev__ double value(const double* coeff, double x)
	{	double tR, tL, b[6]; getBernsteinCoeffs(coeff, x, tR, tL, b);
		//Evaluate Bernstein polynomial by de Casteljau's reduction
		register double c[5], d[4];
		for(int i=0; i<5; i++) c[i] = tL*b[i] + tR*b[i+1]; //5->4
		for(int i=0; i<4; i++) d[i] = tL*c[i] + tR*c[i+1]; //4->3
		for(int i=0; i<3; i++) c[i] = tL*d[i] + tR*d[i+1]; //3->2
		for(int i=0; i<2; i++) d[i] = tL*c[i] + tR*c[i+1]; //2->1
		return tL*d[0] + tR*d[1]; //1->0
	}
	
	//Compute derivative of quintic spline
	__hostanddev__ double deriv(const double* coeff, double x)
	{	double tR, tL, b[6]; getBernsteinCoeffs(coeff, x, tR, tL, b);
		//Derivative by by de Casteljau's reduction
		register double c[5], d[4];
		for(int i=0; i<5; i++) c[i] = b[i+1] - b[i]; //5->4
		for(int i=0; i<4; i++) d[i] = tL*c[i] + tR*c[i+1]; //4->3
		for(int i=0; i<3; i++) c[i] = tL*d[i] + tR*d[i+1]; //3->2
		for(int i=0; i<2; i++) d[i] = tL*c[i] + tR*c[i+1]; //2->1
		return 5.*(tL*d[0] + tR*d[1]); //1->0
	}
	
	//Gradient propagation corresponding to value
	__hostanddev__ void valueGrad(double E_value, double* E_coeff, double x)
	{	int j = (int)x;
		double tR = x - j; //right weight for interval
		double tL = 1.-tR; //left weight for interval
		register double b[6], c[6];
		//Backtrace de Casteljau's reduction:
		b[0]=tL; b[1]=tR; //0->1
		c[0]=0.; for(int i=0; i<2; i++) { c[i] += tL*b[i]; c[i+1] = tR*b[i]; } //1->2
		b[0]=0.; for(int i=0; i<3; i++) { b[i] += tL*c[i]; b[i+1] = tR*c[i]; } //2->3
		c[0]=0.; for(int i=0; i<4; i++) { c[i] += tL*b[i]; c[i+1] = tR*b[i]; } //3->4
		b[0]=0.; for(int i=0; i<5; i++) { b[i] += tL*c[i]; b[i+1] = tR*c[i]; } //4->5
		//Propagate from Bernstein coefficients 'b' to blip coefficients 'c':
		c[0] = (1./66) * (b[0]);
		c[1] = (1./66) * (26*b[0] + 16*b[1] + 8*b[2] + 4*b[3] + 2*b[4] + b[5]);
		c[2] = (1./33) * (33*b[0] + 33*b[1] + 30*b[2] + 24*b[3] + 18*b[4] + 13*b[5]);
		c[3] = (1./33) * (13*b[0] + 18*b[1] + 24*b[2] + 30*b[3] + 33*b[4] + 33*b[5]);
		c[4] = (1./66) * (b[0] + 2*b[1] + 4*b[2] + 8*b[3] + 16*b[4] + 26*b[5]);
		c[5] = (1./66) * (b[5]);
		//Accumulate E_coeff:
		for(int i=0; i<6; i++) E_coeff[j+i] += E_value * c[i];
	}
}
//! @endcond

#endif // JDFTX_CORE_BSPLINE_H
